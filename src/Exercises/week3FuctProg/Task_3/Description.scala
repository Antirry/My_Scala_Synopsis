package Exercises.week3FuctProg.Task_3

class Description_0 {

/*

Итак, наша сеть будет хранить ассоциации между пунктом отправления и всеми доступными для него пунктами назначения.
 Чтобы эти ассоциации создать, нужно сначала предоставить системе список возможных локаций.
   Следовательно - главная переменная, с которой будет вестись работа - это наименование локации location .

Необходимо реализовать не только основные методы для работы с сетью,
 но и дополнительные ( все же в реальной жизни без аналитики никуда,
  так почему бы не предусмотреть функционал, помогающий получить полезные для бизнеса данные).


Основные методы:

add(network, location) - добавляет локацию в маршрутную сеть
remove(network, location) - удаляет локацию из маршрутной сети
connect(network, pointA, pointB) - связывает две локации между собой
(учитывать, что связь действует в обе стороны, т.е. становится доступным маршрут как туда, так и обратно)
disconnect(network, pointA, pointB) - удаляет маршрут


Дополнительные методы:

nFlights(network, location) - возвращает количество доступных прямых перелетов из заданной точки
mostFlights(network) - возвращает точку, из которой доступно больше всего прямых перелетов
nLocationsWithNoFlights(network) - возвращает количество точек, не включенных ни в один маршрут
isConnected(network, pointA, pointB) - проверяет, связаны ли две точки между собой
(учитывать возможные пересадки, необходимые чтобы перелететь из одной точки в другую)

 */

}

class Description {
/*

  Начнем с метода add:
    add(network, location) - добавляет локацию в маршрутную сеть

  Метод должен выдавать маршрутную сеть, содержащую новую локацию. Определите, что за данные имеем на выходе.

  Ответ: Map[String, Set[String]]

 */
}

class Description_1 {
/*

  Осталось только понять, что писать в теле функции.
   А в теле функции у нас будет всего одна строчка, которую вам и надо составить.

  Ответ:
   network + (location -> Set())

  Этот код добавляет в network новую пару, в которой ключом является location.
 */
}

class Description_2 {
/*

  Второй по сложности метод, что предстоит реализовать - это удаление локации из маршрутной сети.

    remove(network, location) - удаляет локацию из маршрутной сети

  Давайте подумаем, что следует учесть при разработке  этого метода:


  Ответ:

    Все верно, ограничиться удалением только ключа не получится,
     придется позаботиться о том, чтобы ни одного маршрута с указанной для удаления локацией не осталось.

    реализацию рекурсии
    удаление ключа из коллекции

    удаление указанной локации отовсюду, где только может встретиться
    - одним ключом(найденным по названию локации) не ограничиваемся

 */
}

class Description_3 {

/*

  На предыдущем шаге мы выяснили, что из себя представляет тело функции.
  А теперь давайте конкретно укажем, какие строчки кода нам понадобятся:


  Ответ:

1.   // подчищаем маршруты
    def loop(destinations: Set[String], acc: Map[String, Set[String]]): Map[String, Set[String]] =
        if (destinations.isEmpty) acc
        else loop(destinations.tail, disconnect(acc, location, destinations.head))

2.  val disconnected = loop(network(location), network)

3.  disconnected - location // удаляем ключ

 */

}

class Description_4 {

/*

  Переходим к следующему методу.

  connect(network, pointA, pointB) - связывает две локации между собой
   (учитывать, что связь действует в обе стороны, т.е. становится доступным маршрут как туда, так и обратно)

  Соотнесите код, задействованный в connect и его описание


Ответ:
  val routesForA: Set[String] = network(pointA) - получаем доступные маршруты для точки А
  val routesForB: Set[String] = network(pointB) - получаем доступные маршруты для точки B

  network + (pointA -> (routesForA + pointB)) + (pointB -> (routesForB + pointA))  -
  добавляем новый маршрут в сеть

 */

}

class Description_5 {

/*

  Каким образом мы бы могли реализовать функцию

  nLocationsWithNoFlights(network) - возвращает количество точек, не включенных ни в один маршрут

  Как думаете, что подойдет для этой функции?



Ответ:

  network.count(_._2.isEmpty)
  network.view.filterKeys(key => network(key).isEmpty).size
  network.count(pair => pair._2.isEmpty)
  network.view.filter(pair => pair._2.isEmpty).size
  network.view.filterKeys(key => network(key).size == 0).size

 */

}